% 
%  chapter7.tex
%
\chapter{Conclusions and Future Work}\label{ch:conclusion}

The platform CASCIFFO was developed with the main goal of modernizing \acrshort{hff}'s clinical investigation unit, bringing new simple and effective ways of managing clinical trials. 
This management includes tracking the progress of proposals and clinical trials; asset management in clinical trials; financial management by keeping track of budget use; scheduling visits transparent to their physical location (face-to-face or tele-consultation); management and tracking of patients who are added to a clinical trial as participants and finally allowing data to be exported into Excel files.

Defining the platform's functional requirements was the first step in developing it. This allows us to gain a clear understanding of the problems that need to be addressed and create a suitable solution for each problem according to their needs. Additionally, by delineating the functional requirements, the business logic flow will be derived naturally from their analysis. 

To help with visualization of the requirements, several \acrfull{ui} mock-ups were created with the goal for providing a guideline on addressing each functional requirement.

Upon completing this step, we began an analysis of the technology and frameworks that will be used in CASCIFFO's implementation. 
The platform was planned to have 2 main modules, the \acrfull{be} module that manages business logic, and the \acrfull{fe} module where user interactive begins and presents the platform's capabilities to the user. The interaction of these modules was defined to be over HTTP, by exposing the \acrshort{be} as a REST API to be consumed by the \acrshort{fe}.

For the database, the choice of database system was \textit{PostgreSQL}~\cite{postgresql}, chosen for its capabilities, available support through the community and documentation.

For the \acrshort{be} module the framework of choice was \textit{Spring WebFlux}~\cite{spring-webflux} as it provides support for a fully non-blocking I/O environment. Not only is it fully capable of receiving and responding over HTTP in a reactive manner, while also integrating with the \textit{R2DBC driver}~\cite{r2dbc}; a database driver capable of making non-blocking access calls to a certain database. 
The advantages of a non-blocking I/O appeal to the scalability of the platform as well as the capability of handling concurrent requests with a single thread. While in a synchronous programming model, a worker thread that processes a request waits for I/O operations to finish. On the other hand, in an asynchronous programming model, or non-blocking I/O environment, a worker thread can begin attending other requests while it awaits for the previous I/O process to finish. 
Thus, while the former approach requires a thread-pool with N worker threads to handle N requests simultaneously, the latter can handle N requests simultaneously with a single thread. Notice that in both cases we consider that handlers are making I/O work. 
In the case that the request is making CPU bound operations and little to no I/O work, the gain in the non-blocking environment is less significant, because the threads won't be able to start attending to other requests while the CPU is actively performing operations to fulfill the request. 
In the context of CASCIFFO, it is rare the occasion that a request does not have I/O bound processing, as it also communicates with the database. As such, the support and use of a non-blocking environment will benefit the quality of the platform.
In the context of cloud or a container environment, such as Heroku or Docker, it is easier to create a single-threaded environment than a multi-threaded environment with a fixed number of threads when the expected amount of incoming concurrent requests isn't specified.
In \textit{Spring} framework there are two different technological stacks denoted as \textit{Spring MVC} for synchronous blocking I/0 and \textit{Spring WebFlux} for asynchronous non-blocking I/O. Nevertheless, we do not expect to have significant requests overhead on CASCIFFO and both options are valid to the implementation of CASCIFFO. \textit{Spring MVC} is effortless and easy to implement. Yet, we decided to take this challenge and use the latest generation technology embracing the latest trends in asynchronous communication, as an opportunity to study it and test it in the field with real use cases.

Moving onto the technology that makes up the \acrshort{fe}, we chose a \textit{Node.js} environment along with the framework \textit{React.js} in conjunction with the language \textit{TypeScript}. 
Since the \acrshort{fe} consists in the development of the website of the platform CASCIFFO, choosing \textit{Node.js} was an immediate choice, \textit{React.js} was chosen due to its simplicity in creating websites by using a reactive and component based approach; incredible popularity and support; the community and documentation available makes it an alluring framework to choose. Finally, with \textit{TypeScript} being a super set of \textit{JavaScript}, offering type safety and many other features that allow detection of errors at compile time was the first and foremost choice and final decision for the programming language of the \acrshort{fe} module. 

Once the second phase of development - choosing the technology for each module - finished, the third phase began. This phase consists in the implementation of both modules accompanied by continuous testing for quality assurance. To facilitate continuous development, the \textit{Heroku} cloud-based service was used, which allowed for testing, rapid maintenance and feature delivery. 
Having both modules in separate \textit{Heroku} instances allowed either one to work independently, which enabled the deployment of newer versions on either module without implying a deployment on the one other as well. Although the \acrshort{fe} relies heavily on the \acrshort{be} module for data, it can function on its own as a \acrfull{pwa}. 
As a plus, the database was also stored in conjunction with the \acrshort{be} module in its \textit{Heroku} instance. 

Although the use of \textit{Heroku} allows for testing by simply accessing the URL of the instance in question, since it's using their free plan, the instance will hibernate after a set timeout. Accessing the instance URL will wake it up and make it ready for use. This process takes time and causes a delay on startup. As of November 28th of 2022, \textit{Heroku} has deprecated~\footnote{https://devcenter.heroku.com/changelog-items/2461}~\label{fn:heroku-rip} some of it's free resources, including \textit{PostgreSQL} hosting, thus not allowing the recreation of this process without spending resources.  

When it came to testing each module, the \acrshort{be} module was tested using unit tests for each non-controller component. The controllers, which consume the HTTP requests, were tested with the help of the framework \textit{Postman}. The tests made for the \acrshort{fe} module consisted on two main aspects, the performance evaluation made by the \textit{Developer Tool Lighthouse}~\cite{lighthouse} along with the feedback given by the team at \acrshort{hff} accompanying us.

Once the implementation was finished, the platform was deployed on-premises on a dedicated server instance running on Ubuntu and served by the Apache service. Based on the needs of the \acrshort{hff}, the application was hosted via HTTP, not HTTPS, which deters the possibility for the \acrshort{fe} to be a \acrshort{pwa}. This could be a future next step, as the module is fully ready to operate as a \acrshort{pwa} needing only to be hosted via HTTPS.

Looking at the developed solution, we can conclude that the functional requirements were met, though some deviated from their original~\acrshort{ui} mock-up design due to sudden business logic changes or previously uncounted obstacles.
As to the non-functional requirements, the integration of the \acrshort{hff}/\acrshort{uic} database - "Admission", was not completed in time due to data regulation issues, having been replaced with the possibility of adding patient and investigator data manually through the platform.
Although it is early to conclude whether the platform CASCIFFO will achieve its desired goal in full, it is certain that it's a step into the right direction.

Setting the sight on the future of CASCIFFO, an interesting take on the next steps of development could be the addition of new functionalities and quality of life improvements, such as:
\begin{itemize}
    \item Having a screen dedicated to the finance and juridical roles to display proposals pending validation; 
    \item Adding a timeline with events on the financial aspect of a clinical trial;
    \item Having push notifications;
    \item Integrating with a finance module to provide improved ways of finance management of clinical trials;
    \item Integration with a calendar API to merge the scheduled visits in it;
    \item User based calendars;
    \item Implementation of a Publisher Subscribe~\footnote{https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber}\label{fn:pub-sub} methodology to allow users to 'Subscribe' to updates on certain clinical trials;
    \item Standardize the responses made by the \acrlong{be} module. For example using HATEOAS.
    \item Analysis of hosting via HTTP vs HTTPS, as the latter allows the platform to align with the standards of a \acrshort{pwa}.
    \item Integration with the HFF's internal database to pull patient and researcher data over having to manually add each of them.
\end{itemize}
